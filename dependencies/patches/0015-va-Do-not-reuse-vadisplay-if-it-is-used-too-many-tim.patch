diff --git a/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvadisplay_drm.c b/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvadisplay_drm.c
index b5440429e16f..fe3118a2bd4c 100644
--- a/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvadisplay_drm.c
+++ b/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvadisplay_drm.c
@@ -57,6 +57,7 @@ struct _GstVaDisplayDrm
   /* <private> */
   gchar *path;
   gint fd;
+  gboolean is_i915;
 };
 
 /**
@@ -155,6 +156,11 @@ gst_va_display_drm_create_va_display (GstVaDisplay * display)
     }
     GST_INFO_OBJECT (self, "DRM render node with kernel driver %s",
         version->name);
+    if (strncmp (version->name, "i915", 4) == 0) {
+      self->is_i915 = TRUE;
+    } else {
+      self->is_i915 = FALSE;
+    }
     drmFreeVersion (version);
   }
 #endif
@@ -189,6 +195,14 @@ gst_va_display_drm_init (GstVaDisplayDrm * self)
   self->fd = -1;
 }
 
+gboolean
+gst_va_display_drm_check_i915 (GstVaDisplay * display)
+{
+  GstVaDisplayDrm *self = GST_VA_DISPLAY_DRM (display);
+
+  return self->is_i915;
+}
+
 /**
  * gst_va_display_drm_new_from_path:
  * @path: the path to the DRM device
diff --git a/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvadisplay_drm.h b/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvadisplay_drm.h
index d14a1f64484a..e0ee1b0bd356 100644
--- a/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvadisplay_drm.h
+++ b/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvadisplay_drm.h
@@ -38,5 +38,7 @@ GST_VA_API
 GType                 gst_va_display_drm_get_type         (void);
 GST_VA_API
 GstVaDisplay *        gst_va_display_drm_new_from_path    (const gchar * path);
+GST_VA_API
+gboolean              gst_va_display_drm_check_i915       (GstVaDisplay * display);
 
 G_END_DECLS
diff --git a/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvautils.c b/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvautils.c
index 02f520ae2164..101267e0b279 100644
--- a/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvautils.c
+++ b/subprojects/gst-plugins-bad/gst-libs/gst/va/gstvautils.c
@@ -122,6 +122,7 @@ gst_va_context_query (GstElement * element, const gchar * context_type)
 {
   GstQuery *query;
   GstContext *ctxt = NULL;
+  GstStructure *str = NULL;
 
   _init_context_debug ();
 
@@ -132,11 +133,23 @@ gst_va_context_query (GstElement * element, const gchar * context_type)
   query = gst_query_new_context (context_type);
   if (_gst_va_run_query (element, query, GST_PAD_SRC)) {
     gst_query_parse_context (query, &ctxt);
+
+    if (ctxt) {
+      str = gst_context_writable_structure (ctxt);
+      gst_structure_set (str, "from-neighbor", G_TYPE_BOOLEAN, TRUE, NULL);
+    }
+
     GST_CAT_INFO_OBJECT (GST_CAT_CONTEXT, element,
         "found context (%p) in downstream query", ctxt);
     gst_element_set_context (element, ctxt);
   } else if (_gst_va_run_query (element, query, GST_PAD_SINK)) {
     gst_query_parse_context (query, &ctxt);
+
+    if (ctxt) {
+      str = gst_context_writable_structure (ctxt);
+      gst_structure_set (str, "from-neighbor", G_TYPE_BOOLEAN, TRUE, NULL);
+    }
+
     GST_CAT_INFO_OBJECT (GST_CAT_CONTEXT, element,
         "found context (%p) in upstream query", ctxt);
     gst_element_set_context (element, ctxt);
@@ -274,6 +287,8 @@ gst_va_handle_set_context (GstElement * element, GstContext * context,
 {
   GstVaDisplay *display_replacement = NULL;
   const gchar *context_type, *type_name;
+  gboolean from_neighbor = FALSE;
+  const GstStructure *str;
 
   _init_context_debug ();
 
@@ -284,6 +299,11 @@ gst_va_handle_set_context (GstElement * element, GstContext * context,
 
   context_type = gst_context_get_context_type (context);
 
+  str = gst_context_get_structure (context);
+  if (!gst_structure_get (str, "from-neighbor", G_TYPE_BOOLEAN,
+            &from_neighbor, NULL))
+    from_neighbor = FALSE;
+
   if (g_strcmp0 (context_type, GST_VA_DISPLAY_HANDLE_CONTEXT_TYPE_STR) == 0) {
     type_name = G_OBJECT_TYPE_NAME (element);
     if (!gst_context_get_va_display (context, type_name, render_device_path,
@@ -295,6 +315,21 @@ gst_va_handle_set_context (GstElement * element, GstContext * context,
   }
 
   if (display_replacement) {
+#ifdef HAVE_LIBDRM
+    if (!gst_va_display_drm_check_i915(display_replacement)) {
+      if (gst_va_display_is_implementation (display_replacement,
+          GST_VA_IMPLEMENTATION_INTEL_IHD) && !from_neighbor) {
+          guint ref;
+
+          ref = g_atomic_int_get (&((GObject *) display_replacement)->ref_count);
+          if (ref > 4) {
+            gst_object_unref (display_replacement);
+          return FALSE;
+          }
+      }
+    }
+#endif
+
     gst_object_replace ((GstObject **) display_ptr,
         (GstObject *) display_replacement);
     gst_object_unref (display_replacement);
